name: ðŸš€ Blue-Green Staging Deployment

on:
  workflow_call:
    inputs:
      deployment_environment:
        description: 'Staging environment (blue/green)'
        required: false
        default: 'auto'
        type: string
      health_check_timeout:
        description: 'Health check timeout in seconds'
        required: false
        default: '300'
        type: string
      rollback_on_failure:
        description: 'Auto rollback on deployment failure'
        required: false
        default: true
        type: boolean
    outputs:
      deployment_url:
        description: 'URL of the deployed environment'
        value: ${{ jobs.deploy.outputs.deployment_url }}
      environment:
        description: 'Deployed environment (blue/green)'
        value: ${{ jobs.deploy.outputs.environment }}
      deployment_status:
        description: 'Deployment status'
        value: ${{ jobs.deploy.outputs.status }}
  workflow_dispatch:
    inputs:
      deployment_environment:
        description: 'Staging environment (blue/green/auto)'
        required: false
        default: 'auto'
        type: choice
        options: ['auto', 'blue', 'green']
      health_check_timeout:
        description: 'Health check timeout in seconds'
        required: false
        default: '300'
        type: string
      rollback_on_failure:
        description: 'Auto rollback on deployment failure'
        required: false
        default: true
        type: boolean

env:
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '22.17.0'
  HEALTH_CHECK_TIMEOUT: ${{ github.event.inputs.health_check_timeout || '300' }}
  ROLLBACK_ENABLED: ${{ github.event.inputs.rollback_on_failure || 'true' }}
  DEPLOYMENT_ENV: ${{ github.event.inputs.deployment_environment || 'auto' }}

concurrency:
  group: staging-deployment-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false  # Don't cancel deployments

jobs:
  # ðŸŽ¯ Pre-Deployment Validation
  pre-deployment:
    name: ðŸŽ¯ Pre-Deployment Validation
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      target-environment: ${{ steps.env-selection.outputs.target-env }}
      current-environment: ${{ steps.env-selection.outputs.current-env }}
      deployment-id: ${{ steps.env-selection.outputs.deployment-id }}
    steps:
      - name: ðŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ðŸŽ¯ Environment Selection Logic
        id: env-selection
        run: |
          echo "ðŸŽ¯ Determining target deployment environment..."
          
          DEPLOYMENT_ID="deploy-$(date +%Y%m%d-%H%M%S)-$(echo $GITHUB_SHA | cut -c1-8)"
          echo "deployment-id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          
          # Simulate checking current active environment
          # In production, this would query your load balancer or service mesh
          CURRENT_ENV="blue"  # This would be determined dynamically
          echo "current-env=$CURRENT_ENV" >> $GITHUB_OUTPUT
          
          if [ "${{ env.DEPLOYMENT_ENV }}" = "auto" ]; then
            # Auto-select opposite environment
            if [ "$CURRENT_ENV" = "blue" ]; then
              TARGET_ENV="green"
            else
              TARGET_ENV="blue"
            fi
          else
            TARGET_ENV="${{ env.DEPLOYMENT_ENV }}"
          fi
          
          echo "target-env=$TARGET_ENV" >> $GITHUB_OUTPUT
          
          echo "ðŸ“Š Deployment Plan:"
          echo "  - Current Active: $CURRENT_ENV"
          echo "  - Target Environment: $TARGET_ENV"
          echo "  - Deployment ID: $DEPLOYMENT_ID"

      - name: ðŸ” Pre-Deployment Checks
        run: |
          echo "ðŸ” Running pre-deployment validation..."
          
          # Check if required secrets are available
          if [ -z "${{ secrets.STAGING_DEPLOY_KEY }}" ]; then
            echo "âš ï¸ STAGING_DEPLOY_KEY secret not found"
          fi
          
          # Validate deployment configuration
          echo "âœ… Pre-deployment checks completed"

  # ðŸ—ï¸ Build and Prepare Artifacts
  build-artifacts:
    name: ðŸ—ï¸ Build Deployment Artifacts
    needs: pre-deployment
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: ðŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ðŸ Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: ðŸ“¦ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: 'frontend/package-lock.json'

      - name: ðŸ”§ Build Backend
        run: |
          echo "ðŸ”§ Building backend application..."
          pip install -r requirements.txt
          
          # Create deployment package
          mkdir -p deployment/backend
          cp -r src backend deployment/
          cp requirements.txt deployment/
          
          # Generate version info
          cat > deployment/version.json << EOF
          {
            "version": "${{ github.sha }}",
            "build_time": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "branch": "${{ github.ref_name }}",
            "deployment_id": "${{ needs.pre-deployment.outputs.deployment-id }}",
            "environment": "${{ needs.pre-deployment.outputs.target-environment }}"
          }
          EOF

      - name: ðŸ”§ Build Frontend
        working-directory: frontend
        run: |
          echo "ðŸ”§ Building frontend application..."
          npm ci --prefer-offline --no-audit
          npm run build
          
          # Copy to deployment package
          mkdir -p ../deployment/frontend
          cp -r dist/* ../deployment/frontend/

      - name: ðŸ“¦ Create Deployment Archive
        run: |
          echo "ðŸ“¦ Creating deployment archive..."
          cd deployment
          tar -czf ../deployment-${{ needs.pre-deployment.outputs.target-environment }}.tar.gz .
          cd ..
          
          echo "ðŸ“Š Deployment package size:"
          ls -lh deployment-${{ needs.pre-deployment.outputs.target-environment }}.tar.gz

      - name: ðŸ“¦ Cache Deployment Artifacts
        uses: actions/cache@v4
        with:
          path: deployment-${{ needs.pre-deployment.outputs.target-environment }}.tar.gz
          key: deployment-artifacts-${{ needs.pre-deployment.outputs.deployment-id }}

      - name: ðŸ“Š Upload Deployment Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: deployment-artifacts-${{ needs.pre-deployment.outputs.target-environment }}
          path: deployment-${{ needs.pre-deployment.outputs.target-environment }}.tar.gz
          retention-days: 30

  # ðŸš€ Blue-Green Deployment
  deploy:
    name: ðŸš€ Deploy to ${{ needs.pre-deployment.outputs.target-environment }}
    needs: [pre-deployment, build-artifacts]
    runs-on: ubuntu-latest
    timeout-minutes: 20
    environment: 
      name: staging-${{ needs.pre-deployment.outputs.target-environment }}
      url: ${{ steps.deploy-app.outputs.deployment_url }}
    outputs:
      deployment_url: ${{ steps.deploy-app.outputs.deployment_url }}
      environment: ${{ needs.pre-deployment.outputs.target-environment }}
      status: ${{ steps.deploy-app.outputs.status }}
    steps:
      - name: ðŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ðŸ“¦ Restore Deployment Artifacts
        uses: actions/cache@v4
        with:
          path: deployment-${{ needs.pre-deployment.outputs.target-environment }}.tar.gz
          key: deployment-artifacts-${{ needs.pre-deployment.outputs.deployment-id }}

      - name: ðŸš€ Deploy Application
        id: deploy-app
        run: |
          echo "ðŸš€ Deploying to ${{ needs.pre-deployment.outputs.target-environment }} environment..."
          
          # Extract deployment package
          tar -xzf deployment-${{ needs.pre-deployment.outputs.target-environment }}.tar.gz
          
          # Simulate deployment process
          # In production, this would deploy to your infrastructure
          TARGET_ENV="${{ needs.pre-deployment.outputs.target-environment }}"
          
          echo "ðŸ“‹ Deployment Configuration:"
          echo "  - Target Environment: $TARGET_ENV"
          echo "  - Deployment ID: ${{ needs.pre-deployment.outputs.deployment-id }}"
          echo "  - Health Check Timeout: ${{ env.HEALTH_CHECK_TIMEOUT }}s"
          
          # Simulate deployment steps
          echo "âš™ï¸ Step 1/5: Preparing infrastructure..."
          sleep 2
          
          echo "ðŸ“¦ Step 2/5: Deploying backend services..."
          # Here you would deploy to your staging environment
          sleep 3
          
          echo "ðŸŽ¨ Step 3/5: Deploying frontend application..."
          sleep 2
          
          echo "ðŸ”§ Step 4/5: Updating configuration..."
          sleep 1
          
          echo "ðŸ¥ Step 5/5: Starting health checks..."
          
          # Set deployment URL (would be dynamic in production)
          DEPLOYMENT_URL="https://staging-${TARGET_ENV}.ai-pdf-scholar.com"
          echo "deployment_url=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
          echo "status=deployed" >> $GITHUB_OUTPUT
          
          echo "âœ… Deployment completed successfully!"
          echo "ðŸŒ Application URL: $DEPLOYMENT_URL"

  # ðŸ¥ Health Check and Validation
  health-check:
    name: ðŸ¥ Health Check & Validation
    needs: [pre-deployment, deploy]
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: ðŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ðŸ¥ Comprehensive Health Checks
        id: health-check
        run: |
          echo "ðŸ¥ Running comprehensive health checks..."
          
          DEPLOYMENT_URL="${{ needs.deploy.outputs.deployment_url }}"
          TARGET_ENV="${{ needs.deploy.outputs.environment }}"
          TIMEOUT="${{ env.HEALTH_CHECK_TIMEOUT }}"
          
          echo "ðŸŽ¯ Health Check Configuration:"
          echo "  - URL: $DEPLOYMENT_URL"
          echo "  - Environment: $TARGET_ENV"
          echo "  - Timeout: ${TIMEOUT}s"
          
          # Create health check script
          cat > health_check.py << 'EOF'
          import time
          import sys
          import json
          from urllib.request import urlopen
          from urllib.error import URLError
          
          def check_endpoint(url, timeout=300):
              """Check if an endpoint is healthy"""
              start_time = time.time()
              
              while time.time() - start_time < timeout:
                  try:
                      # Simulate health check
                      # response = urlopen(f"{url}/health", timeout=10)
                      # In simulation, we'll assume success after some checks
                      
                      print(f"ðŸ” Checking {url}/health...")
                      time.sleep(2)
                      
                      print(f"ðŸ” Checking {url}/api/v1/system/status...")
                      time.sleep(2)
                      
                      print(f"ðŸ” Checking frontend assets...")
                      time.sleep(1)
                      
                      print("âœ… All health checks passed!")
                      return True
                      
                  except Exception as e:
                      print(f"âš ï¸ Health check failed: {e}")
                      time.sleep(10)
              
              print("âŒ Health check timeout exceeded")
              return False
          
          if __name__ == "__main__":
              url = sys.argv[1]
              timeout = int(sys.argv[2])
              success = check_endpoint(url, timeout)
              sys.exit(0 if success else 1)
          EOF
          
          # Run health checks
          if python health_check.py "$DEPLOYMENT_URL" "$TIMEOUT"; then
            echo "health-status=healthy" >> $GITHUB_OUTPUT
            echo "âœ… Health checks passed!"
          else
            echo "health-status=unhealthy" >> $GITHUB_OUTPUT
            echo "âŒ Health checks failed!"
            exit 1
          fi

      - name: ðŸ§ª Smoke Tests
        run: |
          echo "ðŸ§ª Running smoke tests on deployed environment..."
          
          # Create smoke test suite
          cat > smoke_tests.py << 'EOF'
          import json
          import time
          
          def run_smoke_tests(base_url):
              """Run basic smoke tests"""
              tests = [
                  {"name": "Health Check", "endpoint": "/health"},
                  {"name": "System Status", "endpoint": "/api/v1/system/status"},
                  {"name": "Frontend Assets", "endpoint": "/"},
              ]
              
              passed = 0
              total = len(tests)
              
              for test in tests:
                  print(f"ðŸ§ª Running: {test['name']}")
                  # Simulate test execution
                  time.sleep(1)
                  print(f"âœ… {test['name']} passed")
                  passed += 1
              
              print(f"ðŸ“Š Smoke Test Results: {passed}/{total} passed")
              return passed == total
          
          if __name__ == "__main__":
              success = run_smoke_tests("${{ needs.deploy.outputs.deployment_url }}")
              exit(0 if success else 1)
          EOF
          
          python smoke_tests.py

  # ðŸ”„ Traffic Switching (Blue-Green Switch)
  traffic-switch:
    name: ðŸ”„ Traffic Switching
    needs: [pre-deployment, deploy, health-check]
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: success()
    steps:
      - name: ðŸ”„ Switch Traffic to New Environment
        run: |
          echo "ðŸ”„ Switching traffic to ${{ needs.deploy.outputs.environment }} environment..."
          
          CURRENT_ENV="${{ needs.pre-deployment.outputs.current-environment }}"
          TARGET_ENV="${{ needs.deploy.outputs.environment }}"
          
          echo "ðŸ“Š Traffic Switch Plan:"
          echo "  - From: $CURRENT_ENV"
          echo "  - To: $TARGET_ENV"
          
          # Simulate traffic switching
          echo "âš™ï¸ Step 1/3: Updating load balancer configuration..."
          sleep 2
          
          echo "ðŸ”„ Step 2/3: Gradual traffic migration (0% -> 100%)..."
          for percent in 25 50 75 100; do
            echo "  ðŸ“ˆ Traffic to $TARGET_ENV: $percent%"
            sleep 1
          done
          
          echo "âœ… Step 3/3: Traffic switch completed!"
          echo "ðŸŒ All traffic now routed to $TARGET_ENV environment"

      - name: ðŸ§ª Post-Switch Validation
        run: |
          echo "ðŸ§ª Validating post-switch behavior..."
          
          # Simulate post-switch validation
          sleep 3
          echo "âœ… Post-switch validation completed successfully!"

  # ðŸ›¡ï¸ Rollback (If Needed)
  rollback:
    name: ðŸ›¡ï¸ Automated Rollback
    needs: [pre-deployment, deploy, health-check, traffic-switch]
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: failure() && env.ROLLBACK_ENABLED == 'true'
    steps:
      - name: ðŸš¨ Rollback Detection
        run: |
          echo "ðŸš¨ Deployment failure detected!"
          echo "Initiating automated rollback..."

      - name: ðŸ”„ Execute Rollback
        run: |
          echo "ðŸ”„ Rolling back to ${{ needs.pre-deployment.outputs.current-environment }}..."
          
          CURRENT_ENV="${{ needs.pre-deployment.outputs.current-environment }}"
          FAILED_ENV="${{ needs.deploy.outputs.environment }}"
          
          echo "ðŸ“Š Rollback Plan:"
          echo "  - Failed Environment: $FAILED_ENV"
          echo "  - Rollback Target: $CURRENT_ENV"
          
          # Simulate rollback process
          echo "âš™ï¸ Step 1/4: Reverting traffic routing..."
          sleep 2
          
          echo "ðŸ›‘ Step 2/4: Stopping failed deployment..."
          sleep 2
          
          echo "ðŸ”„ Step 3/4: Restoring previous configuration..."
          sleep 2
          
          echo "âœ… Step 4/4: Rollback completed!"
          echo "ðŸŒ Traffic restored to $CURRENT_ENV environment"

      - name: ðŸ“§ Rollback Notification
        run: |
          echo "ðŸ“§ Sending rollback notification..."
          echo "Deployment failed and was automatically rolled back."
          # Here you would send alerts via Slack, email, etc.

  # ðŸ“Š Deployment Report
  deployment-report:
    name: ðŸ“Š Deployment Report
    needs: [pre-deployment, deploy, health-check, traffic-switch]
    if: always()
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: ðŸ“Š Generate Deployment Report
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          # ðŸš€ Blue-Green Staging Deployment Report
          
          ## ðŸ“Š Deployment Summary
          
          | Stage | Status | Duration | Details |
          |-------|---------|----------|---------|
          | ðŸŽ¯ Pre-Deployment | ${{ needs.pre-deployment.result }} | ~2 min | Environment selection & validation |
          | ðŸ—ï¸ Build Artifacts | ${{ needs.build-artifacts.result }} | ~10 min | Frontend & backend build |
          | ðŸš€ Deploy | ${{ needs.deploy.result }} | ~15 min | Blue-green deployment |
          | ðŸ¥ Health Check | ${{ needs.health-check.result }} | ~5 min | Comprehensive validation |
          | ðŸ”„ Traffic Switch | ${{ needs.traffic-switch.result }} | ~3 min | Load balancer update |
          
          ## ðŸŽ¯ Deployment Details
          
          - **Target Environment**: ${{ needs.pre-deployment.outputs.target-environment }}
          - **Previous Environment**: ${{ needs.pre-deployment.outputs.current-environment }}
          - **Deployment ID**: ${{ needs.pre-deployment.outputs.deployment-id }}
          - **Deployment URL**: ${{ needs.deploy.outputs.deployment_url }}
          - **Rollback Enabled**: ${{ env.ROLLBACK_ENABLED }}
          
          ## âœ… Deployment Benefits
          
          - **Zero Downtime**: Blue-green deployment ensures no service interruption
          - **Instant Rollback**: Failed deployments automatically rollback
          - **Health Validation**: Comprehensive health checks before traffic switch
          - **Gradual Migration**: Progressive traffic switching reduces risk
          
          EOF
          
          # Add rollback information if it occurred
          if [[ "${{ needs.rollback.result }}" != "" ]]; then
            cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          
          ## ðŸ›¡ï¸ Rollback Information
          
          - **Rollback Triggered**: ${{ needs.rollback.result }}
          - **Reason**: Deployment failure detected
          - **Recovery Time**: ~5 minutes
          
          EOF
          fi