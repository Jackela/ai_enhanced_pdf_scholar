# ============================================================================
# Prometheus Adapter for Custom Metrics
# Enables HPA to use custom application metrics from Prometheus
# Specifically configured for AI PDF Scholar auto-scaling needs
# ============================================================================

apiVersion: v1
kind: Namespace
metadata:
  name: custom-metrics

---
# Prometheus Adapter Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: custom-metrics-apiserver
  name: custom-metrics-apiserver
  namespace: custom-metrics
spec:
  replicas: 1
  selector:
    matchLabels:
      app: custom-metrics-apiserver
  template:
    metadata:
      labels:
        app: custom-metrics-apiserver
      name: custom-metrics-apiserver
    spec:
      serviceAccountName: custom-metrics-apiserver
      containers:
      - name: custom-metrics-apiserver
        image: k8s.gcr.io/prometheus-adapter/prometheus-adapter:v0.11.0
        args:
        - --secure-port=6443
        - --tls-cert-file=/var/run/serving-cert/tls.crt
        - --tls-private-key-file=/var/run/serving-cert/tls.key
        - --logtostderr=true
        - --prometheus-url=http://prometheus.ai-pdf-scholar.svc.cluster.local:9090/
        - --metrics-relist-interval=1m
        - --v=4
        - --config=/etc/adapter/config.yaml
        ports:
        - containerPort: 6443
          name: https
        resources:
          requests:
            cpu: 250m
            memory: 200Mi
          limits:
            cpu: 500m
            memory: 500Mi
        volumeMounts:
        - mountPath: /var/run/serving-cert
          name: volume-serving-cert
          readOnly: true
        - mountPath: /etc/adapter/
          name: config
          readOnly: true
        - mountPath: /tmp
          name: tmp-vol
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop: ["all"]
          readOnlyRootFilesystem: true
          runAsNonRoot: true
          runAsUser: 10001
          seccompProfile:
            type: RuntimeDefault
        livenessProbe:
          httpGet:
            path: /livez
            port: https
            scheme: HTTPS
          initialDelaySeconds: 30
          timeoutSeconds: 5
        readinessProbe:
          httpGet:
            path: /readyz
            port: https
            scheme: HTTPS
          initialDelaySeconds: 20
          timeoutSeconds: 5
      nodeSelector:
        kubernetes.io/os: linux
      volumes:
      - name: volume-serving-cert
        secret:
          secretName: serving-certs
      - name: config
        configMap:
          name: adapter-config
      - name: tmp-vol
        emptyDir: {}

---
# Service Account for Prometheus Adapter
apiVersion: v1
kind: ServiceAccount
metadata:
  labels:
    app: custom-metrics-apiserver
  name: custom-metrics-apiserver
  namespace: custom-metrics

---
# ClusterRole for resource reading
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  labels:
    app: custom-metrics-apiserver
  name: custom-metrics-server-resources
rules:
- apiGroups:
  - custom.metrics.k8s.io
  resources: ["*"]
  verbs: ["*"]

---
# ClusterRole for system auth delegating
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  labels:
    app: custom-metrics-apiserver
  name: custom-metrics-resource-reader
rules:
- apiGroups: [""]
  resources: ["namespaces", "pods", "services"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["apps"]
  resources: ["deployments", "replicasets"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["extensions"]
  resources: ["deployments/scale", "replicasets/scale"]
  verbs: ["get", "update"]

---
# ClusterRoleBinding for resource reading
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  labels:
    app: custom-metrics-apiserver
  name: custom-metrics:system:auth-delegator
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:auth-delegator
subjects:
- kind: ServiceAccount
  name: custom-metrics-apiserver
  namespace: custom-metrics

---
# ClusterRoleBinding for resource reader
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  labels:
    app: custom-metrics-apiserver
  name: custom-metrics-resource-reader
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: custom-metrics-resource-reader
subjects:
- kind: ServiceAccount
  name: custom-metrics-apiserver
  namespace: custom-metrics

---
# HPA controller to custom metrics binding
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  labels:
    app: custom-metrics-apiserver
  name: hpa-controller-custom-metrics
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: custom-metrics-server-resources
subjects:
- kind: ServiceAccount
  name: horizontal-pod-autoscaler
  namespace: kube-system

---
# Role for auth reader
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  labels:
    app: custom-metrics-apiserver
  name: custom-metrics-auth-reader
  namespace: kube-system
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: extension-apiserver-authentication-reader
subjects:
- kind: ServiceAccount
  name: custom-metrics-apiserver
  namespace: custom-metrics

---
# Service for Prometheus Adapter
apiVersion: v1
kind: Service
metadata:
  labels:
    app: custom-metrics-apiserver
  name: custom-metrics-apiserver
  namespace: custom-metrics
spec:
  ports:
  - name: https
    port: 443
    targetPort: 6443
  selector:
    app: custom-metrics-apiserver

---
# APIService for custom metrics
apiVersion: apiregistration.k8s.io/v1
kind: APIService
metadata:
  labels:
    app: custom-metrics-apiserver
  name: v1beta1.custom.metrics.k8s.io
spec:
  service:
    name: custom-metrics-apiserver
    namespace: custom-metrics
  group: custom.metrics.k8s.io
  version: v1beta1
  insecureSkipTLSVerify: true
  groupPriorityMinimum: 100
  versionPriority: 100

---
# APIService for external metrics
apiVersion: apiregistration.k8s.io/v1
kind: APIService
metadata:
  labels:
    app: custom-metrics-apiserver
  name: v1beta1.external.metrics.k8s.io
spec:
  service:
    name: custom-metrics-apiserver
    namespace: custom-metrics
  group: external.metrics.k8s.io
  version: v1beta1
  insecureSkipTLSVerify: true
  groupPriorityMinimum: 100
  versionPriority: 100

---
# ConfigMap with adapter configuration
apiVersion: v1
kind: ConfigMap
metadata:
  labels:
    app: custom-metrics-apiserver
  name: adapter-config
  namespace: custom-metrics
data:
  config.yaml: |
    rules:
    # HTTP request metrics
    - seriesQuery: 'http_requests_per_second{namespace!="",pod!=""}'
      seriesFilters: []
      resources:
        overrides:
          namespace:
            resource: namespace
          pod:
            resource: pod
      name:
        matches: "^(.*)_per_second$"
        as: "${1}_per_second"
      metricsQuery: 'sum(<<.Series>>{<<.LabelMatchers>>}) by (<<.GroupBy>>)'

    - seriesQuery: 'http_request_duration_p95_seconds{namespace!="",pod!=""}'
      seriesFilters: []
      resources:
        overrides:
          namespace:
            resource: namespace
          pod:
            resource: pod
      name:
        matches: "^(.*)_p95_seconds$"
        as: "${1}_p95_seconds"
      metricsQuery: 'avg(<<.Series>>{<<.LabelMatchers>>}) by (<<.GroupBy>>)'

    - seriesQuery: 'http_request_duration_p50_seconds{namespace!="",pod!=""}'
      seriesFilters: []
      resources:
        overrides:
          namespace:
            resource: namespace
          pod:
            resource: pod
      name:
        matches: "^(.*)_p50_seconds$"
        as: "${1}_p50_seconds"
      metricsQuery: 'avg(<<.Series>>{<<.LabelMatchers>>}) by (<<.GroupBy>>)'

    # RAG-specific metrics
    - seriesQuery: 'rag_queries_per_second{namespace!="",pod!=""}'
      seriesFilters: []
      resources:
        overrides:
          namespace:
            resource: namespace
          pod:
            resource: pod
      name:
        matches: "^rag_(.*)_per_second$"
        as: "rag_${1}_per_second"
      metricsQuery: 'sum(<<.Series>>{<<.LabelMatchers>>}) by (<<.GroupBy>>)'

    - seriesQuery: 'rag_query_duration_p95_seconds{namespace!="",pod!=""}'
      seriesFilters: []
      resources:
        overrides:
          namespace:
            resource: namespace
          pod:
            resource: pod
      name:
        matches: "^rag_(.*)_p95_seconds$"
        as: "rag_${1}_p95_seconds"
      metricsQuery: 'avg(<<.Series>>{<<.LabelMatchers>>}) by (<<.GroupBy>>)'

    # Document processing metrics
    - seriesQuery: 'document_processing_queue_depth{namespace!="",pod!=""}'
      seriesFilters: []
      resources:
        overrides:
          namespace:
            resource: namespace
          pod:
            resource: pod
      name:
        matches: "^document_(.*)_depth$"
        as: "document_${1}_depth"
      metricsQuery: 'avg(<<.Series>>{<<.LabelMatchers>>}) by (<<.GroupBy>>)'

    - seriesQuery: 'document_processing_rate_per_minute{namespace!="",pod!=""}'
      seriesFilters: []
      resources:
        overrides:
          namespace:
            resource: namespace
          pod:
            resource: pod
      name:
        matches: "^document_(.*)_per_minute$"
        as: "document_${1}_per_minute"
      metricsQuery: 'sum(<<.Series>>{<<.LabelMatchers>>}) by (<<.GroupBy>>)'

    - seriesQuery: 'document_processing_errors_rate{namespace!="",pod!=""}'
      seriesFilters: []
      resources:
        overrides:
          namespace:
            resource: namespace
          pod:
            resource: pod
      name:
        matches: "^document_(.*)_errors_rate$"
        as: "document_${1}_errors_rate"
      metricsQuery: 'sum(<<.Series>>{<<.LabelMatchers>>}) by (<<.GroupBy>>)'

    # User activity metrics
    - seriesQuery: 'active_user_sessions{namespace!="",pod!=""}'
      seriesFilters: []
      resources:
        overrides:
          namespace:
            resource: namespace
          pod:
            resource: pod
      name:
        matches: "^active_(.*)_sessions$"
        as: "active_${1}_sessions"
      metricsQuery: 'sum(<<.Series>>{<<.LabelMatchers>>}) by (<<.GroupBy>>)'

    - seriesQuery: 'concurrent_users{namespace!="",pod!=""}'
      seriesFilters: []
      resources:
        overrides:
          namespace:
            resource: namespace
          pod:
            resource: pod
      name:
        matches: "^concurrent_(.*)$"
        as: "concurrent_${1}"
      metricsQuery: 'sum(<<.Series>>{<<.LabelMatchers>>}) by (<<.GroupBy>>)'

    # Efficiency metrics
    - seriesQuery: 'memory_efficiency_ratio{namespace!="",pod!=""}'
      seriesFilters: []
      resources:
        overrides:
          namespace:
            resource: namespace
          pod:
            resource: pod
      name:
        matches: "^(.*)_efficiency_ratio$"
        as: "${1}_efficiency_ratio"
      metricsQuery: 'avg(<<.Series>>{<<.LabelMatchers>>}) by (<<.GroupBy>>)'

    - seriesQuery: 'cpu_efficiency_ratio{namespace!="",pod!=""}'
      seriesFilters: []
      resources:
        overrides:
          namespace:
            resource: namespace
          pod:
            resource: pod
      name:
        matches: "^(.*)_efficiency_ratio$"
        as: "${1}_efficiency_ratio"
      metricsQuery: 'avg(<<.Series>>{<<.LabelMatchers>>}) by (<<.GroupBy>>)'

    # Quality metrics
    - seriesQuery: 'service_quality_score{namespace!="",pod!=""}'
      seriesFilters: []
      resources:
        overrides:
          namespace:
            resource: namespace
          pod:
            resource: pod
      name:
        matches: "^(.*)_quality_score$"
        as: "${1}_quality_score"
      metricsQuery: 'avg(<<.Series>>{<<.LabelMatchers>>}) by (<<.GroupBy>>)'

    - seriesQuery: 'rag_cache_hit_rate{namespace!="",pod!=""}'
      seriesFilters: []
      resources:
        overrides:
          namespace:
            resource: namespace
          pod:
            resource: pod
      name:
        matches: "^(.*)_hit_rate$"
        as: "${1}_hit_rate"
      metricsQuery: 'avg(<<.Series>>{<<.LabelMatchers>>}) by (<<.GroupBy>>)'

    # Business metrics
    - seriesQuery: 'business_value_score{namespace!="",pod!=""}'
      seriesFilters: []
      resources:
        overrides:
          namespace:
            resource: namespace
          pod:
            resource: pod
      name:
        matches: "^business_(.*)_score$"
        as: "business_${1}_score"
      metricsQuery: 'avg(<<.Series>>{<<.LabelMatchers>>}) by (<<.GroupBy>>)'

    - seriesQuery: 'cost_per_request{namespace!="",pod!=""}'
      seriesFilters: []
      resources:
        overrides:
          namespace:
            resource: namespace
          pod:
            resource: pod
      name:
        matches: "^cost_per_(.*)$"
        as: "cost_per_${1}"
      metricsQuery: 'avg(<<.Series>>{<<.LabelMatchers>>}) by (<<.GroupBy>>)'

    # External metrics (not pod-specific)
    externalRules:
    - seriesQuery: 'scaling_prediction_confidence'
      metricsQuery: '<<.Series>>'
      name:
        matches: "^scaling_(.*)_confidence$"
        as: "scaling_${1}_confidence"

    - seriesQuery: 'predicted_load_next_15min'
      metricsQuery: '<<.Series>>'
      name:
        matches: "^predicted_(.*)_next_15min$"
        as: "predicted_${1}_next_15min"

    - seriesQuery: 'peak_hour_indicator'
      metricsQuery: '<<.Series>>'
      name:
        matches: "^peak_(.*)_indicator$"
        as: "peak_${1}_indicator"

    # Database metrics (external)
    - seriesQuery: 'database_size_mb'
      metricsQuery: '<<.Series>>'
      name:
        matches: "^database_(.*)_mb$"
        as: "database_${1}_mb"

    - seriesQuery: 'db_active_connections'
      metricsQuery: '<<.Series>>'
      name:
        matches: "^db_(.*)_connections$"
        as: "db_${1}_connections"

    # Resource metrics (for fallback)
    - seriesQuery: 'container_memory_working_set_bytes{namespace!="",pod!="",container!=""}'
      seriesFilters:
      - isNot: __name__
      resources:
        overrides:
          namespace:
            resource: namespace
          pod:
            resource: pod
          container:
            resource: container
      name:
        matches: "^container_(.*)_bytes$"
        as: "container_${1}_bytes"
      metricsQuery: 'avg(<<.Series>>{<<.LabelMatchers>>}) by (<<.GroupBy>>)'

    - seriesQuery: 'container_cpu_usage_seconds_total{namespace!="",pod!="",container!=""}'
      seriesFilters:
      - isNot: __name__
      resources:
        overrides:
          namespace:
            resource: namespace
          pod:
            resource: pod
          container:
            resource: container
      name:
        matches: "^container_(.*)_seconds_total$"
        as: "container_${1}_seconds_total"
      metricsQuery: 'avg(rate(<<.Series>>{<<.LabelMatchers>>}[5m])) by (<<.GroupBy>>)'

---
# Secret for serving certificates (placeholder)
apiVersion: v1
kind: Secret
metadata:
  labels:
    app: custom-metrics-apiserver
  name: serving-certs
  namespace: custom-metrics
type: Opaque
data:
  tls.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCi4uLnBsYWNlaG9sZGVyIGNlcnRpZmljYXRlLi4uCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K
  tls.key: LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCi4uLnBsYWNlaG9sZGVyIHByaXZhdGUga2V5Li4uCi0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0K

---
# ServiceMonitor for monitoring the adapter itself
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  labels:
    app: custom-metrics-apiserver
  name: custom-metrics-apiserver
  namespace: custom-metrics
spec:
  endpoints:
  - interval: 30s
    port: https
    scheme: https
    tlsConfig:
      insecureSkipVerify: true
  selector:
    matchLabels:
      app: custom-metrics-apiserver