"""
PDF Test Fixtures Generator
Creates standardized PDF test files for consistent testing across
the application. These fixtures support content hash testing,
deduplication testing, and various edge cases.
"""

import shutil
from pathlib import Path

import fitz  # PyMuPDF


class PDFFixtureGenerator:
    """
    Generates standardized PDF test fixtures for consistent testing.
    Features:
    - Pre-defined content scenarios
    - Consistent formatting
    - Known content for hash verification
    - Various edge cases (empty, large, corrupted)
    """

    def __init__(self, fixture_dir: Path | None = None):
        """
        Initialize PDF fixture generator.
        Args:
            fixture_dir: Directory to store fixtures (defaults to tests/fixtures/pdfs)
        """
        if fixture_dir is None:
            self.fixture_dir = Path(__file__).parent / "pdfs"
        else:
            self.fixture_dir = Path(fixture_dir)
        self.fixture_dir.mkdir(parents=True, exist_ok=True)
        self.fixtures: dict[str, Path] = {}

    def create_simple_text_pdf(self, filename: str = "simple_text.pdf") -> Path:
        """
        Create a simple PDF with basic text content.
        Returns:
            Path to created PDF file
        """
        pdf_path = self.fixture_dir / filename
        doc = fitz.open()
        page = doc.new_page()
        # Add simple text content
        text = "This is a simple test PDF document.\nIt contains basic text for content hash testing.\nGenerated by PDFFixtureGenerator."
        page.insert_text((72, 72), text, fontsize=12)
        doc.save(str(pdf_path))
        doc.close()
        self.fixtures[filename] = pdf_path
        return pdf_path

    def create_empty_pdf(self, filename: str = "empty.pdf") -> Path:
        """
        Create an empty PDF with no text content.
        Returns:
            Path to created PDF file
        """
        pdf_path = self.fixture_dir / filename
        doc = fitz.open()
        doc.new_page()  # Empty page with no content
        doc.save(str(pdf_path))
        doc.close()
        self.fixtures[filename] = pdf_path
        return pdf_path

    def create_multi_page_pdf(self, filename: str = "multi_page.pdf") -> Path:
        """
        Create a multi-page PDF with content on each page.
        Returns:
            Path to created PDF file
        """
        pdf_path = self.fixture_dir / filename
        doc = fitz.open()
        # Page 1
        page1 = doc.new_page()
        page1.insert_text(
            (72, 72),
            "This is page 1.\nIt contains the first part of the document.",
            fontsize=12,
        )
        # Page 2
        page2 = doc.new_page()
        page2.insert_text(
            (72, 72),
            "This is page 2.\nIt contains the second part of the document.",
            fontsize=12,
        )
        # Page 3
        page3 = doc.new_page()
        page3.insert_text(
            (72, 72),
            "This is page 3.\nThis is the final page of the test document.",
            fontsize=12,
        )
        doc.save(str(pdf_path))
        doc.close()
        self.fixtures[filename] = pdf_path
        return pdf_path

    def create_identical_content_pdfs(
        self, base_filename: str = "identical_content"
    ) -> list[Path]:
        """
        Create multiple PDFs with identical text content but different file metadata.
        Args:
            base_filename: Base name for the files (will append _1, _2, etc.)
        Returns:
            List of paths to created PDF files
        """
        content = "This text content is identical across multiple PDF files.\nUsed for testing content hash deduplication.\nThe file hashes will be different but content hashes should match."
        pdf_paths = []
        for i in range(1, 4):  # Create 3 identical content files
            filename = f"{base_filename}_{i}.pdf"
            pdf_path = self.fixture_dir / filename
            doc = fitz.open()
            page = doc.new_page()
            page.insert_text((72, 72), content, fontsize=12)
            # Add different metadata to ensure different file hashes
            doc.set_metadata(
                {
                    "title": f"Identical Content Document {i}",
                    "author": f"Test Author {i}",
                    "subject": f"Test Subject {i}",
                    "creator": f"PDFFixtureGenerator v{i}.0",
                }
            )
            doc.save(str(pdf_path))
            doc.close()
            self.fixtures[filename] = pdf_path
            pdf_paths.append(pdf_path)
        return pdf_paths

    def create_different_content_pdfs(
        self, base_filename: str = "different_content"
    ) -> list[Path]:
        """
        Create multiple PDFs with different text content.
        Args:
            base_filename: Base name for the files
        Returns:
            List of paths to created PDF files
        """
        contents = [
            "This is the first document with unique content.\nIt discusses topic A in detail.",
            "This is the second document with different content.\nIt focuses on topic B specifically.",
            "This is the third document with distinct content.\nIt covers topic C comprehensively.",
        ]
        pdf_paths = []
        for i, content in enumerate(contents, 1):
            filename = f"{base_filename}_{i}.pdf"
            pdf_path = self.fixture_dir / filename
            doc = fitz.open()
            page = doc.new_page()
            page.insert_text((72, 72), content, fontsize=12)
            doc.save(str(pdf_path))
            doc.close()
            self.fixtures[filename] = pdf_path
            pdf_paths.append(pdf_path)
        return pdf_paths

    def create_special_characters_pdf(
        self, filename: str = "special_chars.pdf"
    ) -> Path:
        """
        Create a PDF with special characters and Unicode content.
        Returns:
            Path to created PDF file
        """
        pdf_path = self.fixture_dir / filename
        doc = fitz.open()
        page = doc.new_page()
        # Text with special characters, Unicode, and formatting
        text = """Special Characters Test Document
        Unicode Characters: àáâãäåæçèéêë
        Math Symbols: α β γ δ ε ∑ ∫ ∞ ≠ ≤ ≥
        Currency: $ € £ ¥ ₹ ₽
        Punctuation: "quotes" 'apostrophes' —em-dash– –en-dash— …ellipsis
        This tests text normalization for consistent hashing.
        """
        page.insert_text((72, 72), text, fontsize=11)
        doc.save(str(pdf_path))
        doc.close()
        self.fixtures[filename] = pdf_path
        return pdf_path

    def create_large_pdf(
        self, filename: str = "large_document.pdf", pages: int = 50
    ) -> Path:
        """
        Create a large PDF with many pages for performance testing.
        Args:
            filename: Name of the PDF file
            pages: Number of pages to create
        Returns:
            Path to created PDF file
        """
        pdf_path = self.fixture_dir / filename
        doc = fitz.open()
        for page_num in range(1, pages + 1):
            page = doc.new_page()
            text = f"""Page {page_num} of {pages}
            This is a large document created for performance testing.
            It contains multiple pages with varying content to test
            text extraction and content hashing performance.
            Lorem ipsum dolor sit amet, consectetur adipiscing elit.
            Sed do eiusmod tempor incididunt ut labore et dolore magna
            aliqua. Ut enim ad minim veniam, quis nostrud exercitation
            ullamco laboris nisi ut aliquip ex ea commodo consequat.
            Page number: {page_num}
            Total pages: {pages}
            Progress: {page_num/pages*100:.1f}%
            """
            page.insert_text((72, 72), text, fontsize=10)
        doc.save(str(pdf_path))
        doc.close()
        self.fixtures[filename] = pdf_path
        return pdf_path

    def create_binary_identical_pdfs(
        self, filename: str = "binary_identical.pdf"
    ) -> list[Path]:
        """
        Create binary identical PDF files for exact duplication testing.
        Args:
            filename: Base filename (will create copies with _copy suffix)
        Returns:
            List of paths to identical PDF files
        """
        # First create the original
        original_path = self.create_simple_text_pdf(filename)
        # Create binary identical copies
        copy_paths = [original_path]
        for i in range(1, 3):  # Create 2 copies
            copy_filename = f"{Path(filename).stem}_copy_{i}.pdf"
            copy_path = self.fixture_dir / copy_filename
            # Binary copy
            shutil.copy2(original_path, copy_path)
            self.fixtures[copy_filename] = copy_path
            copy_paths.append(copy_path)
        return copy_paths

    def create_corrupted_pdf(self, filename: str = "corrupted.pdf") -> Path:
        """
        Create a corrupted PDF file for error handling testing.
        Returns:
            Path to created (corrupted) file
        """
        pdf_path = self.fixture_dir / filename
        # Create invalid PDF content
        with open(pdf_path, "w") as f:
            f.write(
                "This is not a valid PDF file.\nIt should trigger error handling in PDF parsers."
            )
        self.fixtures[filename] = pdf_path
        return pdf_path

    def create_all_fixtures(self) -> dict[str, Path]:
        """
        Create all standard test fixtures.
        Returns:
            Dictionary mapping fixture names to file paths
        """
        print("Creating PDF test fixtures...")
        # Basic fixtures
        self.create_simple_text_pdf()
        self.create_empty_pdf()
        self.create_multi_page_pdf()
        self.create_special_characters_pdf()
        # Content comparison fixtures
        self.create_identical_content_pdfs()
        self.create_different_content_pdfs()
        # Binary identical fixtures
        self.create_binary_identical_pdfs()
        # Edge cases
        self.create_corrupted_pdf()
        # Performance testing (smaller for CI)
        self.create_large_pdf("medium_document.pdf", pages=10)
        print(f"Created {len(self.fixtures)} PDF test fixtures in {self.fixture_dir}")
        return self.fixtures.copy()

    def cleanup_fixtures(self):
        """Remove all created fixtures."""
        if self.fixture_dir.exists():
            shutil.rmtree(self.fixture_dir)
        self.fixtures.clear()

    def get_fixture_path(self, fixture_name: str) -> Path | None:
        """Get path to a specific fixture."""
        return self.fixtures.get(fixture_name)

    def list_fixtures(self) -> list[str]:
        """List all available fixtures."""
        return list(self.fixtures.keys())


def create_test_fixtures():
    """Convenience function to create all test fixtures."""
    generator = PDFFixtureGenerator()
    return generator.create_all_fixtures()


if __name__ == "__main__":
    # Create fixtures when run directly
    create_test_fixtures()
    print("PDF test fixtures created successfully!")
